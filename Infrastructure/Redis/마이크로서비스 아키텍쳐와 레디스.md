
> 출처 : 도서 [개발자를 위한 레디스](http://acornpub.co.kr/book/redis_for_developers)

- 소프트웨어 아키텍처는 중앙 집약적인 모놀리틱에서, **모듈화된 마이크로서비스 아키텍처**로 발전해왔다.
- 그 변화의 흐름에서 데이터 저장소의 요구사항이 변화하였다.
	- 더이상 관계형 데이터베이스만으로는 모든 기능을 커버할 수 없게 되었다.
	- NoSQL이 생겨나게 된 계기.
- 레디스는 마이크로서비스 아키텍처에서 데이터 저장소 그 이상으로 활용될 수 있는 유연한 데이터베이스이다.

## 데이터 저장소로서의 레디스
- 레디스는 마이크로서비스 아키텍처에서, 각 **서비스별 개별 저장소**로 사용하기에 알맞다.
	- 설치가 간편하다.
	- 최소한의 리소스로, 막대한 처리량을 낼 수 있다.
	- 다양한 자료 구조를 제공한다.
	- 사용이 간단하다.
	- 고가용성을 위한 로드 밸런서나 프록시 등 추가적인 서비스를 설치하지 않고도 하나의 튼튼한 저장소로서의 역할을 수행하기에 충분하다.
- 레디스의 메모리에 있는 데이터는 **주기적으로 디스크에 저장**시킬 수 있다.
	- **AOP(Append Only File)** 또는 **RDB(Redis Database)** 형식으로 저장 가능.
	- 레디스에 장애가 발생해 데이터가 유실되더라도, 백업 파일을 이용하면 다시 복구할 수 있다.

## 메시지 브로커로서의 레디스
- 마이크로서비스 아키텍처에서 각 서비스는 완전히 분리되어 있는 구조로 동작한다.
	- 서로 다른 서비스 간에 **지속적인 통신**이 필요하다.
	- 서비스들 간에 비동기적으로 데이터를 전달할 수 있는 통신 채널을 구현하는것이 좋다.
		- 주로 메시지 큐 또는 stream 과 같은 메시지 브로커를 이용한다.
- 레디스는 서비스 간 메시지를 전달할 때 매우 유용하게 사용할 수 있다.
- 레디스의 **pub/sub** 기능은 가장 간단한 메시징 기능으로, 굉장히 빠르게 동작하며 간단하게 사용할 수 있다.
- pub/sub에서 모든 데이터는 전달된 뒤 삭제되는 **일회성**이다.
	- 모든 메시징 상황에 적합하진 않지만, **fire-and-forget** 패턴이 필요한 간단한 알림(e.g. Notification) 서비스에서는 유용하게 사용할 수 있다.
- 레디스의 **list** 자료 구조는 **메시징 큐**로 사용하기 알맞다.
	- list에서 데이터는 빠르게 **push/pop**을 할 수 있다.
	- 애플리케이션은 대기하다가, list에 새로운 데이터가 들어오면 읽어 갈 수 있는 **블로킹** 기능을 사용할 수도 있다.
		- list에 데이터가 있는지 매번 확인할 필요가 없어짐.
- 레디스의 **stream** 자료 구조를 이용하면, 레디스를 완벽한 스트림 플랫폼으로 활용할 수 있다.
	- stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조이다.
	- 데이터는 **계속해서 추가**되는 방식으로 저장된다. (append-only)
	- 카프카처럼 저장되는 데이터를 읽을 수 있는 **소비자**와 **소비자 그룹**이존재한다.
		- **데이터의 분산 처리**도 가능하다.
	- 저장된 데이터를 **시간대별로 검색**하는 것도 가능하다.