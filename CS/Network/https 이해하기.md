
> https://yozm.wishket.com/magazine/detail/1852/
> https://ko.wikipedia.org/wiki/%EB%94%94%ED%94%BC-%ED%97%AC%EB%A8%BC_%ED%82%A4_%EA%B5%90%ED%99%98

## HTTPS란 무엇인가
- TCP 프로토콜의 일종인 HTTP(Hypertext Transfer Protocol)에 S(Secure)를 더한것.
- HTTPS의 원천 기술로 **SSL(Secure Socket Layer)** 과 **TLS(Transport Layer Security)** 가 있다.
	- 안전한 계층(Layer)을 통신에 추가하는 방식.
- 이 기술을 수행하기 위해 **웹 서버에 설치하는** 것이 **SSL/TLS 인증서**이다.
- TLS는 SSL의 **개선 버전**이다.
	- 그래서 최신 인증서는 대부분 TLS를 사용하지만, 편의상 SSL 인증서라고 부르는 편이다.
- 웹 브라우저는 **공신력 있는 인증서의 정보를 브라우저 내부에 보관**하고 있다.
- **접속하는 웹 사이트에 믿을만한 인증서가 설치되어 있는지 확인**한다.

## SSL 인증서와 SSL 핸드셰이크에 탑재된 기술
- **대칭키 암호화 방식**
- **비대칭키 암호화 방식**
- 통신 대상을 서로가 확인하는 신분 확인
- 믿을 수 있는 SSL 인증서를 위한 디지털 서명
- 디지털 서명을 해주는 인증 기관의 확인
- **공개키를 안전하게 전달하고 공유하기 위한 프로토콜**
- 암호화된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

SSL에 사용된 보안 기술은 암호화, 인증, 서명, 공개키, 무결성 확인 등 매우 다양하기에, 이것만 잘 이해하고 있어도 웬만한 IT 보안 기술에 대한 기본은 이해할 수 있다.
이 중에서 가장 대표적인 암호화 방식 두 개를 살펴본다.

![](../../../assets/대칭키%20암호화%20vs%20공개키%20암호화.png)

### 대칭키 암호화 방식
대칭키 암호화 방식이란, **하나의 암호화키(key)** 로 평문을 암호화하고, 다시 암호문을 원래의 평문으로 복호화할 때 사용하는 방식이다. 키를 단 하나만 사용한다는 간편함이 있지만, 키를 탈취당한다면 내 암호문을 누군가가 복호화하여 볼 수 있다는 치명적인 단점이 있다.

### 공개키 암호화 방식
공개키 암호화 방식은 **공개키(Public Key), 개인키(Private Key)** 를 한 쌍으로 하는 **키-페어(key-pair)** 로 각각 암호화/복호화에 사용한다. 일반적으로 <u>공개키로 암호화</u> 한 것을 <u>개인키로 복호화</u>한다.
개인키를 먼저 만들고, 여기서 공개키를 파생시키는 방식이다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능하다.

> 질문 : 수신자의 공개키로 개인키를 역추산 해낼수는 없을까?
> 답변 : 공개키를 통해서 개인키를 계산해내는것은 현실적으로 불가능하다. (이론적으로는)


## SSL 핸드셰이크 과정

![](../../../assets/SSL%20핸드셰이크%20과정.png)

### 1. 클라이언트 -> 서버 접속 (Client Hello)
웹 사이트 접속에 HTTPS를 사용하는 브라우저는 다음 정보를 Client Hello 단계에서 보낸다.
- 브라우저가 사용하는 **SSL/TLS 버전 정보**
- 브라우저가 사용하는 **암호화 방식 모음(cipher suite)**
- 브라우저가 순간적으로 생성한 **난수**(숫자)
- 만약 이전에 SSL 핸드셰이크가 완료된 상태였다면, 그 때 생성되었던 세션 아이디
- 기타 정보

> **cipher suite** 란?
> - 보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지의 형태로 묶어놓은 것을 의미.
> - 여기서 말하는 보안의 목표는 다음과 같다.
> 	- 안전한 키 교환
> 	- 전달 대상 인증
> 	- 암호화 알고리즘
> 	- 메시지 무결성 확인 알고리즘

### 2. 서버 -> 응답 및 클라이언트에 정보 제공 (Server Hello)
요청을 받은 서버가 클라이언트에 보내는 응답 내용은 다음과 같다.
- 브라우저의 암호화 방식 정보 중, **서버가 지원하고 선택한 암호화 방식(cipher suite)**
- **서버의 공개키가 담긴 SSL 인증서.**
	- 인증서는 **CA(인증 기관, Certificate Authority)** 의 **비밀키로 암호화**되어 발급된 상태.
- 서버가 순간적으로 생성한 **난수**(숫자)
- 클라이언트의 인증서를 요청함. (선택사항)

### 3. 클라이언트 : 서버가 보내준 SSL 인증서가 올바른지 확인.
대부분의 브라우저에는 공신력 있는 CA들의 정보와, **CA가 만든 공개키가 이미 설치**되어 있다.
서버가 보낸 SSL 인증서가 **정말 CA가 만든 것인지를 확인**하기 위해, **내장된 CA 공개키로 암호화된 인증서를 복호화**한다. 정상적으로 복호화 되었다면, CA가 발급한 것이 증명되는 셈이다.
만약 등록된 CA가 아니거나, 등록된 CA가 만든 인증서처럼 꾸몄다면 이 과정에서 발각이 되며, 브라우저에서 경고를 보낸다.

### 4. 클라이언트 : pre-master secret 생성 및 서버로 전송
서버의 인증서에 딸려온 **웹 사이트의 공개키**를 이용해서 서버와 클라이언트가 각각 생성한 난수를 암호화 한다.
이 때, 이 암호화된 데이터를 **pre-master secret** 이라고 한다.

### 5. 서버 : 서버의 개인키로 pre-master secret 복호화
복호화한 값을 **master secret** 값으로 저장한다. 이 값을 사용하여, 방금 브라우저와 만들어진 **연결에 고유한 값을 부여**하기 위한 **세션키**를 생성한다.
세션키는 **대칭키 암호화에 사용**할 것이다. 이것으로 <u>브라우저와 서버 사이에 주고받는 데이터를 암/복호화</u> 한다.

### 6. 서버/클라이언트 : SSL 핸드셰이크 종료 및 HTTPS 통신 시작
정상적으로 SSL 핸드셰이크가 완료되었다. 이제는 **세션키**를 사용하여 **웹 상의 데이터를 암/복호화** 하며, HTTPS 프로토콜을 통해 주고받을 수 있다.
서로 HTTPS 통신이 더이상 이루어지지 않으면, 서로에게 **공유된 세션키를 폐기**한다. 만약 세션키가 여전히 유지되고 있다면, 브라우저는 서버에게 **SSL 핸드셰이크 요청이 아닌 세션 ID를 전송**하기만 하면 된다. (이 부분은 1번 항목에서 언급했음.)

### 기타
SSL 핸드셰이크 과정은 구현체마다 조금씩 다른 옵션을 갖고 있지만, 대부분의 원리는 위의 내용에서 크게 벗어나지 않는다. **SSL 인증서에는 대칭키 방식과 공개키 방식 두 가지를 모두 사용**하며, 모든 **웹 콘텐츠의 전달을 공개키 방식으로 한다면** 웹 서버와 브라우저에게 <u>많은 부담</u>이 된다. 그래서 SSL 핸드셰이크 단계까지는 <u>공개키</u> 방식, 그 이후의 HTTPS 통신은 <u>대칭키</u> 방식을 사용한다.

## HTTPS를 적용하면 100% 안전할까?
HTTPS는 웹에서 보안을 적용하기 위한 **가장 기본적인 단계**이고, 이것으로 <u>모든 보안성이 완벽하게 지켜졌다고 할 수는 없다.</u> 예를 들어 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면, 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있다. 또한 **HTTPS는 전달 구간에 대한 보안 기술**인데, 전달 구간 중간에 해커가 **중간자 공격**을 수행할 수 있는 취약점이 있다면<u> HTTPS는 유지되지만 전달하는 내용은 고스란히 노출</u>되기 때문이다.

